import { type App, normalizePath } from "obsidian";
import type { BookmarkInternalData, ExplorerHiderSettings, Hidden } from "./interface";
import type ExplorerHider from "./main";

export class RulesCompiler {
	plugin: ExplorerHider;
	snippets: Set<Hidden>;
	settings: ExplorerHiderSettings;
	app: App;
	style: HTMLStyleElement | null;
	constructor(plugin: ExplorerHider) {
		this.plugin = plugin;
		this.snippets = plugin.snippets;
		this.settings = plugin.settings;
		this.app = plugin.app;
		this.style = plugin.style;
	}

	/**
	 * The best for folder is to use
	 * .nav-folder-title[data-path^="path"], .nav-folder[data-path^="path"] + .nav-folder-children { display: none; }
	 * @param snippet {Hidden}
	 * @returns {string}
	 */
	createRuleFolderTitle(snippet: Hidden): string | undefined {
		const { path, hiddenInNav: hidden, selector } = snippet;
		const selectorChar = selector ? selector : "^";
		if (snippet.type === "folder") {
			if (!hidden || this.settings.showAll) return;
			return `.nav-folder-title[data-path${selectorChar}="${path}"], .nav-folder-title[data-path${selectorChar}="${path}"] + .nav-folder-children, `;
		} else if (snippet.type === "string") {
			return `.nav-file [data-path="${path}"], `;
		} else {
			return `[data-path="${path}"]:not(.tree-item:has(.bookmark)), `;
		}
	}

	createNavRule(snippet: Hidden) {
		const { hiddenInNav: hidden } = snippet;
		if (!hidden || this.settings.showAll) return;

		return this.createRuleFolderTitle(snippet);
	}

	createRuleForBookMarks(snippet: Hidden, realName: string | undefined) {
		if (!snippet.hiddenInBookmarks) return;
		const { path, hiddenInBookmarks, selector } = snippet;
		if (!hiddenInBookmarks || this.settings.showAll) return;
		const selectorChar = selector ? selector : "";
		const removeExtension = realName ? realName : path.replace(/\.(.*)$/, "");
		return `.tree-item[data-path${selectorChar}="${removeExtension}"]:has(.bookmark), `;
	}

	async createSnippetFile() {
		//use a file in `.obsidian/snippets` to hide files and folders instead of the background
		const obsidianDir = this.app.vault.configDir;
		const snippetsGeneratedFiles = normalizePath(
			`${obsidianDir}/snippets/generated.explorer-hider.css`
		);
		const rules = `/* This file is generated by the Explorer Hider plugin. Do not edit it manually. */\n${this.createRules()}`;
		await this.app.vault.adapter.write(snippetsGeneratedFiles, rules);
	}

	compileNavRules() {
		let rule = "";
		const filteredSnippets = Array.from(this.snippets).filter((s) => s.hiddenInNav);
		filteredSnippets.forEach((snippet) => {
			const useRule = this.createNavRule(snippet);
			if (useRule) rule += useRule;
		});
		if (rule.length > 0) {
			return `${rule.replace(/, $/, "")} { display: none; }`;
		}
		return rule;
	}

	updateSnippet(newSnippet: Hidden, oldSnippet?: Hidden) {
		if (oldSnippet) this.snippets.delete(oldSnippet);
		this.snippets.delete(newSnippet);
		this.snippets.add(newSnippet);
	}

	compileBookmarksRules() {
		let rule = "";
		const filteredSnippets = Array.from(this.snippets).filter((s) => s.hiddenInBookmarks);
		const bookmarksPlugin = this.app.internalPlugins.getEnabledPluginById("bookmarks");
		if (!bookmarksPlugin) return "";
		//@ts-ignore
		const allBookMarksItem: BookmarkInternalData[] = bookmarksPlugin.items;
		filteredSnippets.forEach((snippet) => {
			//find by the path in the bookmarksItems
			const path = allBookMarksItem.find(
				(item) => item.path === snippet.path || item.title === snippet.title
			);
			if (!path && snippet.type === "string") {
				const useRule = this.createRuleForBookMarks(snippet, undefined);
				if (useRule) rule += useRule;
			} else if (path) {
				const useRule = this.createRuleForBookMarks(snippet, path?.title);
				if (useRule) rule += useRule;
			}
		});
		if (rule.length > 0) {
			return `${rule.replace(/, $/, "")} { display: none; }`;
		}

		return rule;
	}

	createRules() {
		return `${this.compileNavRules()}\n${this.compileBookmarksRules()}`;
	}

	createDocumentStyle() {
		this.style = document.createElement("style");
		this.style.id = "explorer-hider";
		this.style.setAttribute("type", "text/css");
		this.style.textContent = this.createRules();
		// biome-ignore lint/correctness/noUndeclaredVariables: this is a global variable
		activeDocument.head.appendChild(this.style);
	}

	async enableStyle(toFile: boolean = false) {
		if (toFile) {
			//create the snippets file if not exist
			await this.createSnippetFile();
			this.app.customCss.setCssEnabledStatus(`generated.explorer-hider`, true);
			//we need to wait a little to wait for obsidian to load the file & enable it before disabling the style
			// biome-ignore lint/correctness/noUndeclaredVariables: Obsidian global function
			await sleep(500);
			this.style?.detach();
		} else {
			this.app.customCss.setCssEnabledStatus(`generated.explorer-hider`, false);
			this.style?.detach();
			this.createDocumentStyle();
		}
		this.app.workspace.trigger("css-change");
	}

	async reloadStyle() {
		this.style?.detach();
		if (this.settings.useSnippets) await this.createSnippetFile();
		else this.createDocumentStyle();

		this.app.workspace.trigger("css-change");
	}
}
